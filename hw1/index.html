<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-ryan_a">cal-cs184-student.github.io/hw-webpages-ryan_a</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw1-ryana">github.com/cal-cs184-student/sp25-hw1-ryana</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		<p>
		To rasterize a single-color triangle, we need to find which pixel’s centers fall inside the triangle, and then set the color of those pixels in the framebuffer. I implemented this process as follows:
		</p>
		<p>
		First, I find the bounding box of the triangle by taking the minimums and maximums of the x and y coordinates of the triangle's vertices. This bounding box saves me from checking every pixel in the framebuffer, as only pixels within the bounding box can possibly be inside the triangle.
		</p>
		<p>
		Next, I need a way to test if a pixel’s center is within a triangle. I do this by performing three “line tests” to see where the pixel is relative to the three line segments that form the triangle. More specifically, a “line test”, returns the scalar projection of a point onto the vector perpendicular to the vector between two given points. Mathematically, this is done as follows:
		<ol>
			<li>Take in three points: pPixel, p0, p1</li>
			<li>Rotate the vector from p0 to p1 counterclockwise by 90 degrees</li>
			<li>Return the dot product of this rotated vector with the vector from p0 to pPixel</li>
			This can be simplified to the formula: \(-(y1-y0)*(xP-x0) + (x1-x0)*(yP-y0)\)
		</ol>
		</p>
		<p>
		The use of this function is that the sign of the return value tells me which side of the given vector the point was on, with a negative value meaning left, positive meaning right, and 0 meaning the point was directly on the line (which my implementation considers to be inside of the triangle). Now, I perform three line tests using the position of the center of the pixel and the three vectors winding around the triangle from vertex 0 to 1 to 2. One thing to watch out for here is that triangles could be wound either clockwise or counterclockwise, as shown in figures 1 and 2.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="clockwiseTri.png" width="400px"/>
				  <figcaption>Figure 1: Clockwise wound triangle.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="counterclockwiseTri.png" width="400px"/>
				  <figcaption>Figure 2: Counter-Clockwise wound triangle.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<p>
		Visually, if a triangle is wound clockwise, to be inside the triangle the point must be on the right side of all three vectors, and thus all line tests should all return <= 0. If a triangle is wound counterclockwise, however, the point must be on the left of all three vectors, so the line tests should all return >= 0. Alternatively, if the point is outside the triangle, the line tests must return both negative and positive values, regardless of the winding of the triangle. Thus, I can say that a point is within the triangle if the line tests are either all negative or all positive. This means my implementation can bypass ever having to solve for which way the triangle is wound.
		</p>
		<p>
		Finally, while looping through every pixel in the bounding box, the last step is to color in the pixels that are inside the triangle by changing their color in the sample buffer. With this done, my implementation was able to render all of the tests shown below.
		</p>
		<p>
		In terms of optimization, my implementation is no slower than one that checks each pixel in the bounding box, as that is what my implementation does. There are other possible optimizations, such the tiled approach described in lecture, but I did not add these to my implementation.
		</p>
		<p>
		An interesting result of triangle rasterization can be seen in figure 4 (test4.svg), where a very thin triangle can end up with parts of it missing. The explanation for this is simply that the missing part of the triangle squeezed in between the pixel's centers in that area, and thus was not rendered.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="test3.png" width="400px"/>
				  <figcaption>Figure 3: test3.svg.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="test4.png" width="400px"/>
				  <figcaption>Figure 4: test4.svg.</figcaption>
				</td>
			  </tr>
				<tr>
				<td style="text-align: center;">
				  <img src="test5.png" width="400px"/>
				  <figcaption>Figure 5: test5.svg.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="test6.png" width="400px"/>
				  <figcaption>Figure 6: test6.svg.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		<p>
		Supersampling is a technique in which a scene is rendered at a higher resolution, then downsampled back to the original resolution. 
		My implementation does this by rendering the points, lines, and triangles to a higher resolution buffer (sample_buffer), which is then downsampled by averaging as it is written into the frame_buffer to be displayed on the screen.
		The benefit of this is that it can reduce aliasing problems like jagged triangle edges or texture aliasing issues by increasing the sampling frequency.
		The downside is a large performance cost due to having to render at a higher resolution.
		</p>
		For my implementation, I first had to handle changing the dimensions of the sample_buffer.
		This only required minor modifications to RasterizerImp::set_sample_rate() and RasterizerImp::set_framebuffer_target(), where I multiplied the sample_buffer's size by the supersampling rate.
		The next step was to implement the downsampling when the sample_buffer is used to fill the framebuffer, which I did in RasterizerImp::resolve_to_framebuffer().
		Here, every pixel in the frame_buffer is filled with the average color of all the pixels in the sample_buffer that it covers.
		Next, I fixed the fact that rendering points and lines had been broken by the supersampling (since points and lines were only 1 pixel wide in the sample_buffer, they ended up much more faint after downsampling).
		To fix this I modified fill_pixel(), the function used for drawing points and lines, to fill the entire square in the sample_buffer that it would have covered without super sampling, effectively making points and lines ignore the supersampling.
		Finally, implementing supersampling for triangles required only minor modifications to my rasterize_triangle() function.
		By first multiplying the coordinates of the triangle's vertices by the sampling factor, I could leave the rest of my function almost unchanged, with it just believing that I was rendering a bigger triangle onto a bigger screen.
		
		<p>
		Below are the results of supersampling at different rates. As you can see it makes the resulting edges much smoother, and it solves the problem of very thin triangles getting split. 
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="test4_1.png" width="400px"/>
				  <figcaption>1x Supersampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="test4_4.png" width="400px"/>
				  <figcaption>4x Supersampling.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="test4_9.png" width="400px"/>
				  <figcaption>9x Supersampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="test4_16.png" width="400px"/>
				  <figcaption>16x Supersampling.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<h2>Task 3: Transforms</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 4: Barycentric coordinates</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>

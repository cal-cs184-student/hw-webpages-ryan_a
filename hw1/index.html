<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-ryan_a">cal-cs184-student.github.io/hw-webpages-ryan_a</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw1-ryana">github.com/cal-cs184-student/sp25-hw1-ryana</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		To rasterize a single-color triangle, we simply need to find which pixels fall inside the triangle, and set the color of those pixels in the framebuffer to that of the triangle. I implemented this process in three steps:
		<ol>
			<li>Find the bounding box of the triangle by taking the mins and maxs of the x and y coordinates of the triangle's vertices. This saves us from looping through all pixels in the framebuffer, as only pixels withing the bounding box can possibly be inside the triangle.</li>
			<li>For every pixel in the bounding box, perform three "line tests" to check if the pixel's center point lies within the triangle
				<ul>
				<li>What a "line test" does is check if a point (the pixel's center) falls on the left or right hand side of the vector between point 0 and point 1 (two of the triangles vertices). This is done by first rotating the vector from point 0 to point 1 counter-clockwise by 90 degrees as (x,y) -> (-y,x), giving us the vector facing left of our original vector. Then, project the vector between point 0 and the pixel's center point onto this left vector by taking a dot product. If this dot product is positive, the pixel is on the left side of the vector, and if it's negative it's on the right. If it is 0, the pixel's center is directly on the line, which my implementation considers to be inside the triangle.</li>
				<li>Now, I perform three of these line tests using the three vectors wrapping around the triangle from vertice 0 to 1 to 2. If the triangle has clockwise winding (figure 1), the pixel must be on the right hand side of all three vectors, so all three line tests must return <= 0 for the point to be inside the triangle. If the triangle has counter-clockwise winding (figure 2), all line tests must return >= 0. Thus, if the line tests are either all positive or all negative, my implementation can say that the point is inside the triangle, without ever having to find which way the triangle is wound.</li>
				</ul>
			</li>
			<li>If the pixel's center was found to be inside the triangle, simply color that pixel in the framebuffer.</li>
		</ol>
		My implementation is no slower than one that checks each pixel in the bounding box, as that is what my implementation does.
		<br><br>An interesting result of this method of triangle rasterization can be seen in figure 4, where a very thin triangle can be split into parts. The explanation for this simply that that missing part of the triangle squeezed in between the pixel's centers in that area, and thus was not rendered.
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="clockwiseTri.png" width="400px"/>
				  <figcaption>Fig 1: Clockwise wound triangle.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="counterclockwiseTri.png" width="400px"/>
				  <figcaption>Fig 2: Counter-Clockwise wound triangle.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="test3.png" width="400px"/>
				  <figcaption>Fig 3: test3.svg.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="test4.png" width="400px"/>
				  <figcaption>Fig 4: test4.svg.</figcaption>
				</td>
			  </tr>
				<tr>
				<td style="text-align: center;">
				  <img src="test5.png" width="400px"/>
				  <figcaption>Fig 5: test5.svg.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="test6.png" width="400px"/>
				  <figcaption>Fig 6: test6.svg.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		<p>
		Supersampling is a technique in which a scene is rendered at a higher resolution, then downsampled back to the original resolution. 
		My implementation does this by rendering the points, lines, and triangles to a higher resolution buffer (sample_buffer), which is then downsampled by averaging as it is written into the frame_buffer to be displayed on the screen.
		The benefit of this is that it can reduce aliasing problem like jagged triangle edges or texture aliasing problems by increasing our sampling frequency.
		The downside is a large performance cost due to having to render at a higher resolution.
		</p>
		For my implementation, I first had to handle changing the dimensions of the sample_buffer.
		This only required minor modifications to RasterizerImp::set_sample_rate() and RasterizerImp::set_framebuffer_target(), where I multiplied the buffer's size by the supersampling rate.
		The next step was to implement the downsampling when the sample_buffer is used to fill the framebuffer, which I did in RasterizerImp::resolve_to_framebuffer().
		Here, every pixel in the frame_buffer is filled with the average color of all the pixels in the sample_buffer that it covers.
		Next, I fixed the fact that rendering points and lines had been broken by the supersampling (since points and lines were only 1 pixel wide in the sample_buffer, they ended up much more faint after downsampling).
		To fix this I modified fill_pixel(), the function used for drawing points and lines, to fill the entire square in the sample_buffer that it would have covered without super sampling.
		Finally, implementing supersampling for triangles required only minor modifications to my rasterize_triangle() function.
		By first multiplying the coordinates of the vertices by the sampling factor, I could leave the rest of my function almost unchanged, with it just believing that I was rendering a bigger triangle onto a bigger screen.
		<p>
			
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="test4_1.png" width="400px"/>
				  <figcaption>1x Supersampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="test4_4.png" width="400px"/>
				  <figcaption>4x Supersampling.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="test4_9.png" width="400px"/>
				  <figcaption>9x Supersampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="test4_16.png" width="400px"/>
				  <figcaption>16x Supersampling.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<h2>Task 3: Transforms</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 4: Barycentric coordinates</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>

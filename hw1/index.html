<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-ryan_a">cal-cs184-student.github.io/hw-webpages-ryan_a</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw1-ryana">github.com/cal-cs184-student/sp25-hw1-ryana</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		<p>
		To rasterize a single-color triangle, we need to find which pixel’s centers fall inside the triangle, and then set the color of those pixels in the framebuffer. I implemented this process as follows:
		</p>
		<p>
		First, I find the bounding box of the triangle by taking the minimums and maximums of the x and y coordinates of the triangle's vertices. This bounding box saves me from checking every pixel in the framebuffer, as only pixels within the bounding box can possibly be inside the triangle.
		</p>
		<p>
		Next, I need a way to test if a pixel’s center is within a triangle. I do this by performing three “line tests” to see where the pixel is relative to the three line segments that form the triangle. More specifically, a “line test”, returns the scalar projection of a point onto the vector perpendicular to the vector between two given points. Mathematically, this is done as follows:
		<ol>
			<li>Take in three points: pPixel, p0, p1</li>
			<li>Rotate the vector from p0 to p1 counterclockwise by 90 degrees</li>
			<li>Return the dot product of this rotated vector with the vector from p0 to pPixel</li>
			This can be simplified to the formula: \[-(y1-y0)*(xP-x0) + (x1-x0)*(yP-y0)\]
		</ol>
		</p>
		<p>
		The use of this function is that the sign of the return value tells me which side of the given vector the point was on, with a negative value meaning right, positive meaning left, and 0 meaning the point was directly on the line (which my implementation considers to be inside of the triangle). Now, I perform three line tests using the position of the center of the pixel and the three vectors winding around the triangle from vertex 0 to 1 to 2. One thing to watch out for here is that triangles could be wound either clockwise or counterclockwise, as shown in figures 1 and 2.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="clockwiseTri.png" width="400px"/>
				  <figcaption>Figure 1: Clockwise wound triangle.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="counterclockwiseTri.png" width="400px"/>
				  <figcaption>Figure 2: Counterclockwise wound triangle.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<p>
		Visually, if a triangle is wound clockwise, to be inside the triangle the point must be on the right side of all three vectors, and thus all line tests should all return <= 0. If a triangle is wound counterclockwise, however, the point must be on the left of all three vectors, so the line tests should all return >= 0. Alternatively, if the point is outside the triangle, the line tests must return both negative and positive values, regardless of the winding of the triangle. Thus, I can say that a point is within the triangle if the line tests are either all negative or all positive. This means my implementation can bypass ever having to solve for which way the triangle is wound.
		</p>
		<p>
		Finally, while looping through every pixel in the bounding box, the last step is to color in the pixels that are inside the triangle by changing their color in the sample buffer. With this done, my implementation was able to render all of the tests shown below.
		</p>
		<p>
		In terms of optimization, my implementation is no slower than one that checks each pixel in the bounding box, as that is what my implementation does. There are other possible optimizations, such the tiled approach described in lecture, but I did not add these to my implementation.
		</p>
		<p>
		An interesting result of triangle rasterization can be seen in figure 4 (test4.svg), where a very thin triangle can end up with parts of it missing. The explanation for this is simply that the missing part of the triangle squeezed in between the pixel's centers in that area, and thus was not rendered.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task1_test3.png" width="400px"/>
				  <figcaption>Figure 3: test3.svg.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task1_test4.png" width="400px"/>
				  <figcaption>Figure 4: test4.svg.</figcaption>
				</td>
			  </tr>
				<tr>
				<td style="text-align: center;">
				  <img src="task1_test5.png" width="400px"/>
				  <figcaption>Figure 5: test5.svg.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task1_test6.png" width="400px"/>
				  <figcaption>Figure 6: test6.svg.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		<p>
		Supersampling is a technique in which a scene is rendered at a higher resolution than can be displayed, and is then downsampled back to the original resolution. My implementation does this by rendering the points, lines, and triangles into a higher resolution buffer (sample_buffer), which is then downsampled by averaging as it is written into the frame_buffer to be displayed on the screen. The benefit of this is that it can reduce aliasing problems like jagged triangle edges or texture aliasing problems by increasing our sampling frequency. The downside is extra memory usage for the larger buffer as well as a large performance cost due to having to render at a higher resolution.
		</p>
		<p>
		For my implementation, I first had to handle changing the dimensions of the sample_buffer. This only required minor modifications to RasterizerImp::set_sample_rate() and RasterizerImp::set_framebuffer_target(), where I multiplied the buffer's size by the supersampling rate.
		</p>
		<p>
		The next step was to implement the downsampling when the sample_buffer is used to fill the framebuffer, which I did in RasterizerImp::resolve_to_framebuffer(). Here, I fill every pixel in the frame_buffer with the average color of all the pixels in the sample_buffer that it covers.
		</p>
		<p>
		Next, I fixed the fact that rendering points and lines had been broken by the supersampling: since points and lines were only rendered as 1 pixel wide into the sample_buffer, they ended up much more faint after the downsampling. To fix this problem I modified fill_pixel(), the function used for drawing points and lines, and made it fill the entire square in the sample_buffer that it would have covered without super sampling. This makes lines and points unaffected by the supersampling.
		</p>
		<p>
		Finally, implementing supersampling for triangles required only minor modifications to my rasterize_triangle() function. By first multiplying the coordinates of the vertices by the sampling factor, I could leave the rest of my function almost unchanged, with the function just believing that I was rendering a bigger triangle onto a bigger screen.
		</p>
		<p>
		Below are the results of supersampling at different rates. As you can see it makes the triangle’s edges less jagged and solves the aforementioned problem of very thin triangles having missing segments. The explanation for this is that by sampling at a higher resolution, the thin triangle is no longer able to squeeze between the centers of sampling points and thus ends up properly rendered in the higher supersamping rate images.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task2_1x.png" width="400px"/>
				  <figcaption>1x Supersampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task2_4x.png" width="400px"/>
				  <figcaption>4x Supersampling.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="task2_9x.png" width="400px"/>
				  <figcaption>9x Supersampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task2_16x.png" width="400px"/>
				  <figcaption>16x Supersampling.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<h2>Task 3: Transforms</h2>
		<p>
		I implemented the three transformation matrices (translate, rotate, scale) using the formulas given in lecture. Then, I modified the robot.svg file to make cubeman look like he was skiing. This was done by editing the transformations in the svg file and also adding a few extra triangles for the skis, poles and hat.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task3_my_robot.png" width="400px"/>
				  <figcaption>Cubeman Skiing.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task3_rotated.png" width="400px"/>
				  <figcaption>Rotating GUI.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<p>
		Extra Credit: I added the ability to rotate the GUI using the ‘Q’ and ‘E’ keys, as shown above. Before my modification, the transformation stack contained two matrices: svg_to_ndc and ndc_to screen. When any point (or triangle vertex) was being rendered, it would first be multiplied by these matrices to transform it from where it was in the svg file to where it should be displayed to the screen as follows:
		</p>
		<p>
		<code>Vector2D screen_point = ndc_to_screen * svg_to_ndc * svg_point;</code>
		</p>
		<p>
		In order to add the rotation, I added a third matrix to this stack, which applies the rotation before the other two transformations. Thus, the points in svg space are first rotated by my matrix, then sent to normalized device coordinates (NDC) by svg_to_ndc, then transformed to their position on the screen by ndc_to_screen. Since I want the rotation to be done about the center of the image (and not the origin which is at the corner of svg space), a simple rotation matrix would not work. Instead, I have to translate to shift the center of the svg to the origin, then rotate, then translate back, giving the combined matrix as:
		</p>
		<p>
		<code>Matrix3x3 rotM = translate(svg.width / 2, svg.height / 2) * rotate(rotation) * translate(-svg.width/2, -svg.height/2);</code>
		</p>
		<p>
		Now, before rendering, I merge this with the other two matrices with the rotation as the first (rightmost) transformation:
		</p>
		<p>
		<code>Matrix3x3 totalM = ndc_to_screen * svg_to_ndc[current_svg] * rotM;</code>
		</p>
		<p>
		Using this totalM matrix to transform vertices, I can now rotate the image around its center in the GUI.
		</p>
		<p>
		Note: My original design intended for the rotation matrix to be a part of the svg_to_ndc matrix, as this is where it really belongs as it is part of the transformation from svg to ndc space. I planned to apply the rotation to it in the move_view/set_view functions where dragging the image (translating svg_to_ndc) or zooming in (scaling svg_to_ndc) are applied. However, since move_view doesn’t actually remember the current translation or scaling but instead extracts them out of the current svg_to_ndc matrix, having svg_to_ndc be rotated by an off origin rotation would make this process much more complicated. Thus, for the sake of simplicity I made the rotation a separate matrix to avoid interfering with svg_to_ndc.
		</p>
		
		<h2>Task 4: Barycentric coordinates</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>
